server:
  forward-headers-strategy: native # Enable Forwarded Headers support
  shutdown: graceful # Ensures graceful shutdown in containers/k8s
  servlet:
    context-path: /spring # Sets a global prefix between domain & all endpoints, {domain}/{prefix}/{endpoint}
    encoding:
      charset: UTF-8
      enabled: true
      force: true
  port: 8080 #Server port config. Valid range: 0 → 65535
  tomcat:
    threads:
      min-spare: 10 # Keep at least nth idle worker threads ready
      max: 50 # Allow up to nth concurrent request-processing threads(2x number of DB connections)
    max-connections: 100 # Max TCP connections handled at once(2x number of DB connections)
    accept-count: 1000 # Queue size for incoming requests if all threads are busy
    connection-timeout: 60s # Drop a connection if idle too long
    keep-alive-timeout: 60s # Keep-alive socket timeout
    max-swallow-size: 2MB # Max size of discarded request body after error
    basedir: ./logs # Tomcat working directory
    accesslog:
      enabled: true
      directory: access_logs # Access logs go into ./logs/access_log
      pattern: '%h %l %u %t "%r" %s %b %D' # format: clientIP userIdent userAuth timestamp "requestLine" status responseSize(bytes) timeTaken(ms)
      rotate: true # Rotate logs automatically
      rename-on-rotate: true # Old logs renamed instead of overwritten
      file-date-format: .yyyy-MM-dd # Append date to log file name
      suffix: .log # Log files end with .log
      prefix: access_log # Log files start with access_log
  max-http-request-header-size: 16KB # Prevent huge headers (defense vs DoS)
  compression:
    enabled: true # Enable gzip compression for responses
    mime-types: 
     - application/json
     - application/xml
     - text/html
     - text/xml
     - text/plain
    min-response-size: 1KB
  ssl: #SSL TLS, Trust store, Key store
    enabled: false
    protocol: TLS
    enabled-protocols: TLSv1.3,TLSv1.2
    ciphers: 
      - TLS_AES_256_GCM_SHA384  # TLS 1.3
      - TLS_AES_128_GCM_SHA256  # TLS 1.3
      - TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384  # TLS 1.2
      - TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256  # TLS 1.2
    trust-store: classpath:security/truststore.p12 # Holds trusted public certificates
    trust-store-password: changeit
    trust-store-type: PKCS12
    key-store: classpath:security/keystore.p12 # Holds your own identity: your server's private key + certificate
    key-store-password: changeit
    key-store-type: PKCS12
    key-alias: spring #Tell spring which key alias imported in PKCS12 file should use
    client-auth: want	#need: client must provide valid cert (strict), want: client cert is optional, none: no client validation (default)
  http2:
    enabled: true
keycloak:
  auth-server-url: http://localhost:65535
  realm: spring
  client-id: spring
  client-secret: Test@123456
spring:
  security:
    oauth2:
      resourceserver:
        jwt:
          issuer-uri: ${keycloak.auth-server-url}/realms/${keycloak.realm}
          jwk-set-uri: ${keycloak.auth-server-url}/realms/${keycloak.realm}/protocol/openid-connect/certs
  lifecycle:
    timeout-per-shutdown-phase: 30s  # Wait for in-flight requests
  application:
    name: spring
  datasource: #DB Config(Git will auto build using the details config in repository secrets)
    url: jdbc:mysql://localhost:3306/appdb?createDatabaseIfNotExist=true
    username: root
    password: Pass@123
    driver-class-name: com.mysql.cj.jdbc.Driver
    hikari:
      validation-timeout: 5000 # Max time to check if a DB connection is alive before using it (ms)
      maximum-pool-size: 10 # Defines how many connections can be open concurrently
      minimum-idle: 5 # Minimum idle connections in the pool(in count)
      idle-timeout: 600000  # Helps recycle connections and free up resources(in milliseconds). idle-timeout must be less than max-lifetime
      max-lifetime: 1800000  # Helps recycle connections and free up resources(in milliseconds). idle-timeout must be less than max-lifetime
      connection-timeout: 30000  # Maximum time to wait for a connection from the pool before throwing an exception(in milliseconds)
      leak-detection-threshold: 20000  # Helps identify if connections are not closed properly(in milliseconds)
      pool-name: HikariCP
      data-source-properties:
        # JDBC driver optimizations that reduce parsing overhead and improve latency
        cachePrepStmts: true  # Enable caching of prepared statements
        prepStmtCacheSize: 250 # Sets the number of prepared statements that the driver will cache per connection(in count)
        prepStmtCacheSqlLimit: 2048 # Sets the maximum length of SQL statements that will be cached
        useServerPrepStmts: true # Uses server-side prepared statements (MySQL feature); helps reduce client-side parsing
        useSSL: false
        requireSSL: false
        allowPublicKeyRetrieval: true
        # List of ssl mode:
        # DISABLED - SSL is not used
        # PREFERRED - SSL is used if available on the server
        # REQUIRED - SSL is required, but no certificate verification is done.
        # VERIFY_CA - SSL is required, and server cert must be signed by a trusted CA.
        # VERIFY_IDENTITY - Like VERIFY_CA, plus it validates hostname matches certificate CN/SAN.
        sslMode: DISABLED
        trustCertificateKeyStoreUrl: classpath:security/keystore.p12
        trustCertificateKeyStorePassword: changeit
        trustCertificateKeyStoreType: PKCS12
  jpa:
    open-in-view: false # Avoids lazy-loading leaks in enterprise apps
    properties:
      hibernate:
        dialect: org.hibernate.dialect.MySQL8Dialect
    hibernate:
      # none - No action. Hibernate will not touch the schema at all. Use this if you manage the schema manually
      # validate - Hibernate only validates that the schema matches the entity mappings. If something is missing (like a column or table), the app will fail to start. Useful for ensuring correctness without changing schema.
      # update - Hibernate will automatically update the schema to match entity mappings (create missing tables/columns, but not drop). Data is usually preserved, but this can be risky. Useful for dev, not for prod.
      # create - Hibernate will drop and recreate the schema at startup. All existing data is lost. Great for quick testing, but not safe otherwise.
      # create-drop - Same as create, but Hibernate will also drop the schema when the SessionFactory is closed (e.g., when the app shuts down). Useful for integration tests.
      ddl-auto: update
      naming: #To maintain the exact same table & column name defined in JPA class
        physical-strategy: org.hibernate.boot.model.naming.PhysicalNamingStrategyStandardImpl
        implicit-strategy: org.hibernate.boot.model.naming.ImplicitNamingStrategyLegacyJpaImpl
    show-sql: true
  batch: #Batch job enablement config
    job:
      enabled: false
  task: #Schduler enablement config
    scheduling:
      enabled: true	
  mail:
    host: smtp.gmail.com
    port: 587
    username: test@gmail.com
    password: 123456
    properties:
      mail:
        smtp:
          auth: true
          starttls:
            enable: true
    protocol: smtp
    default-encoding: UTF-8
    sender: test@gmail.com
mybatis:
  mapper-locations: 
    - classpath:mybatis/mapper/*.xml # Location(s) of your MyBatis XML mapper files.
  type-aliases-package: com.modal # Package(s) to scan for domain/model classes to create type aliases automatically.
  configuration:
    # Automatically converts column names with underscores (snake_case) to camelCase in Java objects.
    # Example: database column "user_name" → Java property "userName".
    map-underscore-to-camel-case: true
    # Enables MyBatis first-level (per-session) and second-level (optional global) caching.
    # Can improve performance for repeated queries.
    cache-enabled: true
    # Sets the default fetch size for queries.  
    # This is a hint to JDBC driver on how many rows to fetch from DB at a time.
    default-fetch-size: 100
    # Sets the default statement timeout in seconds.  
    # If a query takes longer than this, it will throw a timeout exception.
    default-statement-timeout: 30
    # Lazy loading configuration
    lazy-loading-enabled: false
    aggressive-lazy-loading: false
    # Use column label instead of column name
    use-column-label: true
    # Use generated keys
    use-generated-keys: true
    # Auto-mapping behavior (NONE, PARTIAL, FULL)
    auto-mapping-behavior: PARTIAL
    # Default executor type (SIMPLE, REUSE, BATCH)
    default-executor-type: SIMPLE
    # JDBC type for null values
    jdbc-type-for-null: NULL
    # Log implementation (SLF4J, LOG4J2, STDOUT_LOGGING, etc.)
    log-impl: org.apache.ibatis.logging.slf4j.Slf4jImpl
    # Call setters on nulls
    call-setters-on-nulls: false
project:
  log:
    name: ./logs #dot refer to current path
rate:
  limit:
    defaultRate:
      capacity: 10 #max number of tokens the bucket can hold 
      tokens: 10 #new tokens add per period
      period: 60 #Timeunit, second
    endpoints:
      /v1/auth/basic:
        capacity: 3 #max number of tokens the bucket can hold 
        tokens: 2 #new tokens add per period
        period: 60 #Timeunit, second
      /v1/auth/token:
        capacity: 3 #max number of tokens the bucket can hold 
        tokens: 2 #new tokens add per period
        period: 60 #Timeunit, second
      /v1/template/post:
        capacity: 10 #max number of tokens the bucket can hold 
        tokens: 10 #new tokens add per period
        period: 60 #Timeunit, second
      /v1/template/get:
        capacity: 10 #max number of tokens the bucket can hold 
        tokens: 10 #new tokens add per period
        period: 60 #Timeunit, second
      /v1/template/put:
        capacity: 10 #max number of tokens the bucket can hold 
        tokens: 10 #new tokens add per period
        period: 60 #Timeunit, second
      /v1/template/delete:
       capacity: 10 #max number of tokens the bucket can hold 
       tokens: 10 #new tokens add per period
       period: 60 #Timeunit, second			
allowed:
  origins: ${ALLOWED_ORIGINS:http://localhost:8080,https://localhost:8080}
management: #Spring actuator
  server:
    base-path: /spring  # Sets a global prefix between domain & all endpoints, {domain}/{prefix}/{endpoint}
    address: 0.0.0.0 # bind to private/internal IP only
    port: 8444
    ssl: #SSL TLS, Trust store, Key store
      enabled: false
      protocol: TLS
      enabled-protocols: TLSv1.3,TLSv1.2
      ciphers: 
        - TLS_AES_256_GCM_SHA384  # TLS 1.3
        - TLS_AES_128_GCM_SHA256  # TLS 1.3
        - TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384  # TLS 1.2
        - TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256  # TLS 1.2
      key-store: classpath:security/keystore.p12 # Holds your own identity: your server's private key + certificate
      key-store-password: changeit
      key-store-type: PKCS12
      key-alias: spring #Tell spring which key alias imported in PKCS12 file should use
      client-auth: want #need: client must provide valid cert (strict), want: client cert is optional, none: no client validation (default)
  endpoints:
    web:
      exposure: # endpoint: /actuator
        # health - App & subsystem health
        # info - App metadata (version, build, commit)
        # metrics - Prometheus or custom metrics
        # mappings - Controller endpoints overview
        # loggers - Dynamic log level adjustment
        # threaddump - Thread dump for debugging
        # heapdump - Heap dump for memory troubleshooting
        # httptrace - Recent HTTP request traces
        # auditevents - Audit logging
        # shutdown - Graceful shutdown
        include: health,info,metrics,prometheus,mappings,loggers,threaddump,heapdump,httptrace,auditevents,shutdown
  endpoint:
    health:
      show-components: always
      show-details: always
  health:
    mail:
      enabled: true
  metrics:
    tags:
      application: spring # Optional: customize metrics tags
      environment: dev
      region: slg-my
  tracing: # OpenTelemetry integration
    sampling:
      probability: 1.0 # Full tracing in dev, lower in prod
    baggage:
      remote-fields: X-Request-ID,X-Correlation-ID # Pass these IDs across services for log & trace correlation 
alert:
  slack:
    webhook-url:
  support:
    email:
      to: 
      cc: 
      bcc: jleong963@gmail.com
      replyTo: jleong963@gmail.com
google:
  fcm:
    credentials:
      path: "security/google/firebase/firebase-service-account.json"
  pay:
    key:
      path: "security/google/pay/uat"
springdoc:
  api-docs:
    enabled: true
    path: /api-docs #OpenAPI JSON spec endpoint
  swagger-ui:
    enabled: true
    path: /docs #Swagger UI spec endpoint
    operationsSorter: method #API endpoints are ordered consistently (by HTTP method or tag).
    tagsSorter: alpha #API endpoints are ordered consistently (by HTTP method or tag).
    display-request-duration: true #Shows how long each API call takes (helps with perf debugging).
    tryItOutEnabled: true #Lets developers call APIs from the browser directly.
    syntaxHighlight: #Pretty-prints JSON/XML responses.
      activated: true
  group-configs: #Splits OpenAPI docs into groups.
    - group: v1
      paths-to-match: /api/v1/**
    - group: v2
      paths-to-match: /api/v2/**
resilience4j:
  timelimiter: #Must be in async
    configs: #Global Default Configuration
      default:
        timeout-duration: 1s
        cancel-running-future: true
    instances:
      getAsyncTemplate:
        timeout-duration: 1s
        cancel-running-future: true
      requestAuthToken:
        timeout-duration: 5s
        cancel-running-future: true
  circuitbreaker:
    instances:
      sendEmail:
        # Monitor the last 50 calls to decide if circuit should open
        # Uses a ring buffer to track success/failure of recent calls
        sliding-window-size: 50
        # If ≥50% of calls fail → circuit opens (stops calling the service)
        # Example: If 25 out of 50 calls fail, circuit breaks
        # Lower value (e.g., 30) = more sensitive to failures
        failure-rate-threshold: 50
        # If ≥50% of calls are slow → circuit opens
        # Works together with slow-call-duration-threshold
        # Prevents cascading failures from slow dependencies
        # Example: If 25 out of 50 calls exceed 3s, circuit breaks 
        slow-call-rate-threshold: 50
        # Any call taking longer than 3 seconds is considered "slow"
        # Helps detect degraded performance before complete failure
        # Adjust based on your SLA (e.g., 2s for critical APIs, 5s for batch jobs)
        slow-call-duration-threshold: 3s
        # After circuit opens, wait 10 seconds before testing recovery
        # During this time, all calls immediately fail-fast (no actual calls made)
        # After 10s → circuit moves to HALF_OPEN state to test if service recovered
        # Longer duration (30s-60s) for external services, shorter (5s-10s) for internal
        wait-duration-in-open-state: 10
        # Collect at least 10 calls before calculating failure/slow rates
        # Prevents premature circuit opening on startup or low traffic
        # Example: If only 5 calls made and 3 fail (60%), circuit won't open yet
        # Should be ≤ sliding-window-size (typically 10-20% of window size)
        minimum-number-of-calls: 10
        # When in HALF_OPEN, allow exactly 3 test calls to check service health
        # If all 3 succeed → circuit CLOSES (back to normal)
        # If any fail → circuit reopens immediately and waits again
        # Lower value (2-3) = faster decision, Higher value (5-10) = more thorough test
        permitted-number-of-calls-in-half-open-state: 3
      sendTokenBasedPushNotification:
        # Monitor the last 50 calls to decide if circuit should open
        # Uses a ring buffer to track success/failure of recent calls
        sliding-window-size: 50
        # If ≥50% of calls fail → circuit opens (stops calling the service)
        # Example: If 25 out of 50 calls fail, circuit breaks
        # Lower value (e.g., 30) = more sensitive to failures
        failure-rate-threshold: 50
        # If ≥50% of calls are slow → circuit opens
        # Works together with slow-call-duration-threshold
        # Prevents cascading failures from slow dependencies
        # Example: If 25 out of 50 calls exceed 3s, circuit breaks 
        slow-call-rate-threshold: 50
        # Any call taking longer than 3 seconds is considered "slow"
        # Helps detect degraded performance before complete failure
        # Adjust based on your SLA (e.g., 2s for critical APIs, 5s for batch jobs)
        slow-call-duration-threshold: 3s
        # After circuit opens, wait 10 seconds before testing recovery
        # During this time, all calls immediately fail-fast (no actual calls made)
        # After 10s → circuit moves to HALF_OPEN state to test if service recovered
        # Longer duration (30s-60s) for external services, shorter (5s-10s) for internal
        wait-duration-in-open-state: 10
        # Collect at least 10 calls before calculating failure/slow rates
        # Prevents premature circuit opening on startup or low traffic
        # Example: If only 5 calls made and 3 fail (60%), circuit won't open yet
        # Should be ≤ sliding-window-size (typically 10-20% of window size)
        minimum-number-of-calls: 10
        # When in HALF_OPEN, allow exactly 3 test calls to check service health
        # If all 3 succeed → circuit CLOSES (back to normal)
        # If any fail → circuit reopens immediately and waits again
        # Lower value (2-3) = faster decision, Higher value (5-10) = more thorough test
        permitted-number-of-calls-in-half-open-state: 3
      decryptGooglePayToken:
        # Monitor the last 50 calls to decide if circuit should open
        # Uses a ring buffer to track success/failure of recent calls
        sliding-window-size: 50
        # If ≥50% of calls fail → circuit opens (stops calling the service)
        # Example: If 25 out of 50 calls fail, circuit breaks
        # Lower value (e.g., 30) = more sensitive to failures
        failure-rate-threshold: 50
        # If ≥50% of calls are slow → circuit opens
        # Works together with slow-call-duration-threshold
        # Prevents cascading failures from slow dependencies
        # Example: If 25 out of 50 calls exceed 3s, circuit breaks 
        slow-call-rate-threshold: 50
        # Any call taking longer than 3 seconds is considered "slow"
        # Helps detect degraded performance before complete failure
        # Adjust based on your SLA (e.g., 2s for critical APIs, 5s for batch jobs)
        slow-call-duration-threshold: 3s
        # After circuit opens, wait 10 seconds before testing recovery
        # During this time, all calls immediately fail-fast (no actual calls made)
        # After 10s → circuit moves to HALF_OPEN state to test if service recovered
        # Longer duration (30s-60s) for external services, shorter (5s-10s) for internal
        wait-duration-in-open-state: 10
        # Collect at least 10 calls before calculating failure/slow rates
        # Prevents premature circuit opening on startup or low traffic
        # Example: If only 5 calls made and 3 fail (60%), circuit won't open yet
        # Should be ≤ sliding-window-size (typically 10-20% of window size)
        minimum-number-of-calls: 10
        # When in HALF_OPEN, allow exactly 3 test calls to check service health
        # If all 3 succeed → circuit CLOSES (back to normal)
        # If any fail → circuit reopens immediately and waits again
        # Lower value (2-3) = faster decision, Higher value (5-10) = more thorough test
        permitted-number-of-calls-in-half-open-state: 3
      requestAuthToken:
        # Monitor the last 50 calls to decide if circuit should open
        # Uses a ring buffer to track success/failure of recent calls
        sliding-window-size: 50
        # If ≥50% of calls fail → circuit opens (stops calling the service)
        # Example: If 25 out of 50 calls fail, circuit breaks
        # Lower value (e.g., 30) = more sensitive to failures
        failure-rate-threshold: 50
        # If ≥50% of calls are slow → circuit opens
        # Works together with slow-call-duration-threshold
        # Prevents cascading failures from slow dependencies
        # Example: If 25 out of 50 calls exceed 3s, circuit breaks 
        slow-call-rate-threshold: 50
        # Any call taking longer than 3 seconds is considered "slow"
        # Helps detect degraded performance before complete failure
        # Adjust based on your SLA (e.g., 2s for critical APIs, 5s for batch jobs)
        slow-call-duration-threshold: 3s
        # After circuit opens, wait 10 seconds before testing recovery
        # During this time, all calls immediately fail-fast (no actual calls made)
        # After 10s → circuit moves to HALF_OPEN state to test if service recovered
        # Longer duration (30s-60s) for external services, shorter (5s-10s) for internal
        wait-duration-in-open-state: 10
        # Collect at least 10 calls before calculating failure/slow rates
        # Prevents premature circuit opening on startup or low traffic
        # Example: If only 5 calls made and 3 fail (60%), circuit won't open yet
        # Should be ≤ sliding-window-size (typically 10-20% of window size)
        minimum-number-of-calls: 10
        # When in HALF_OPEN, allow exactly 3 test calls to check service health
        # If all 3 succeed → circuit CLOSES (back to normal)
        # If any fail → circuit reopens immediately and waits again
        # Lower value (2-3) = faster decision, Higher value (5-10) = more thorough test
        permitted-number-of-calls-in-half-open-state: 3
  retry:
    instances:
      sendEmail:
        max-attempts: 3
        wait-duration: 2s
      sendTokenBasedPushNotification:
        max-attempts: 3
        wait-duration: 2s
      decryptGooglePayToken:
        max-attempts: 3
        wait-duration: 2s
      requestAuthToken:
        max-attempts: 3
        wait-duration: 2s
