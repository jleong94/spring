name: Build & Release Spring Boot App  # Name of your GitHub Action workflow (youâ€™ll see this on GitHub Actions tab)

on:
  push:
    branches: ["main", "master", "uat", "staging"]     # Triggers when someone pushes code to listed branch here

permissions:
  contents: write
  pull-requests: write  # ğŸ‘ˆ Add this line
  
jobs:
  build-uat:
    if: github.ref_name == 'uat' || github.ref_name == 'staging' # Only run this job if the branch is main or master
    runs-on: ubuntu-latest             # This workflow runs in a fresh Ubuntu VM (GitHub-hosted)

    steps:
    - name: Checkout Code
      uses: actions/checkout@v4        # Pulls your latest code into the VM so it can build it

    - name: Set up JDK 21
      uses: actions/setup-java@v4
      with:
        distribution: 'temurin'        # Uses Eclipse Temurin JDK
        java-version: '21'             # Set your desired Java version here

    - name: Set UAT Environment Variables # Get secret stored in github repo & set into application yml
      run: |
        echo "SPRING_DATASOURCE_URL=${{ secrets.UAT_SPRING_DATASOURCE_URL }}" >> $GITHUB_ENV
        echo "SPRING_DATASOURCE_USERNAME=${{ secrets.UAT_SPRING_DATASOURCE_USERNAME }}" >> $GITHUB_ENV
        echo "SPRING_DATASOURCE_PASSWORD=${{ secrets.UAT_SPRING_DATASOURCE_PASSWORD }}" >> $GITHUB_ENV
        echo "SMTP_HOST=${{ secrets.UAT_SMTP_HOST }}" >> $GITHUB_ENV
        echo "SMTP_PORT=${{ secrets.UAT_SMTP_PORT }}" >> $GITHUB_ENV
        echo "SMTP_USERNAME=${{ secrets.UAT_SMTP_USERNAME }}" >> $GITHUB_ENV
        echo "SMTP_PASSWORD=${{ secrets.UAT_SMTP_PASSWORD }}" >> $GITHUB_ENV
        mkdir -p src/main/resources/security/firebase
        cat << 'EOF' > src/main/resources/security/firebase/firebase-service-account.json
        ${{ secrets.UAT_FIREBASE_CREDENTIALS_JSON }}
        EOF

    - name: Build with Maven
      run: |  # Builds the JAR file
        if [ -n "${{ secrets.NVD_API_KEY }}" ]; then
          echo "NVD API key detected. Running Dependency-Check..."
          mvn --batch-mode clean verify -Dnvd.api.key=${{ secrets.NVD_API_KEY }}
        else
          echo "No NVD API key found. Skipping Dependency-Check..."
          mvn --batch-mode clean verify -Dnvd.skip=true
        fi

    - name: Create Incremental Version Tag
      id: tagger
      run: |
       git fetch --tags  # ğŸ‘ˆ fetch remote tags to ensure local is synced
       LAST_TAG=$(git tag --list 'v0.*' | sort -V | tail -n 1)
       echo "Last tag found: $LAST_TAG"
       if [[ -z "$LAST_TAG" ]]; then
        LAST_TAG="v0.0" #Default if no tag exists
       fi
       # Extract the numeric part, increment
       LAST_MINOR=${LAST_TAG#v0.} # Remove 'v0.' prefix to get minor version
       NEXT_MINOR=$((LAST_MINOR + 1)) # Increment the version number
       NEW_TAG="v0.${NEXT_MINOR}" # Form the new tag
       echo "New tag: $NEW_TAG"
       git tag "$NEW_TAG" # Create new Git tag
       git push https://x-access-token:${{ secrets.GH_PAT }}@github.com/${{ github.repository }}.git --tags # Push tag to remote
       echo "RELEASE_TAG=$NEW_TAG" >> $GITHUB_ENV # Save tag to environment for later use

    - name: Rename JAR to include version
      run: |
        VERSION_TAG=${{ env.RELEASE_TAG }}
        ORIGINAL_JAR=$(ls target/*.jar | grep -v 'original' | head -n 1) #avoids renaming original-*.jar if spring-boot creates both.
        BASENAME=$(basename "$ORIGINAL_JAR" .jar) #basename strips target/ and .jar, giving you the base name from Maven config.
        NEW_JAR_NAME="target/${BASENAME}-${VERSION_TAG}.jar"
        mv "$ORIGINAL_JAR" "$NEW_JAR_NAME"
        echo "VERSIONED_JAR=$NEW_JAR_NAME" >> $GITHUB_ENV
         	   	   	  	  	
    - name: Upload JAR as GitHub Release Asset
      uses: softprops/action-gh-release@v1
      with:
        tag_name: ${{ env.RELEASE_TAG }}   # â† Use the generated tag
        files: ${{ env.VERSIONED_JAR }}    # Uploads the JAR file from Maven's output to the GitHub "Releases" section

    - name: Install GitHub CLI
      run: sudo apt-get install gh -y # Installs GitHub CLI to interact with GitHub programmatically
  build-prod:
    if: github.ref_name == 'main' || github.ref_name == 'master' # Only run this job if the branch is main or master
    runs-on: ubuntu-latest             # This workflow runs in a fresh Ubuntu VM (GitHub-hosted)

    steps:
    - name: Checkout Code
      uses: actions/checkout@v4        # Pulls your latest code into the VM so it can build it

    - name: Set up JDK 21
      uses: actions/setup-java@v4
      with:
        distribution: 'temurin'        # Uses Eclipse Temurin JDK
        java-version: '21'             # Set your desired Java version here

    - name: Set UAT Environment Variables # Get secret stored in github repo & set into application yml
      run: |
        echo "SPRING_DATASOURCE_URL=${{ secrets.SPRING_DATASOURCE_URL }}" >> $GITHUB_ENV
        echo "SPRING_DATASOURCE_USERNAME=${{ secrets.SPRING_DATASOURCE_USERNAME }}" >> $GITHUB_ENV
        echo "SPRING_DATASOURCE_PASSWORD=${{ secrets.SPRING_DATASOURCE_PASSWORD }}" >> $GITHUB_ENV
        echo "SMTP_HOST=${{ secrets.SMTP_HOST }}" >> $GITHUB_ENV
        echo "SMTP_PORT=${{ secrets.SMTP_PORT }}" >> $GITHUB_ENV
        echo "SMTP_USERNAME=${{ secrets.SMTP_USERNAME }}" >> $GITHUB_ENV
        echo "SMTP_PASSWORD=${{ secrets.SMTP_PASSWORD }}" >> $GITHUB_ENV
        echo "SMTP_SENDER=${{ secrets.SMTP_SENDER }}" >> $GITHUB_ENV
        mkdir -p src/main/resources/security/firebase
        cat << 'EOF' > src/main/resources/security/firebase/firebase-service-account.json
        ${{ secrets.FIREBASE_CREDENTIALS_JSON }}
        EOF

    - name: Build with Maven
      run: |  # Builds the JAR file
        if [ -n "${{ secrets.NVD_API_KEY }}" ]; then
          echo "NVD API key detected. Running Dependency-Check..."
          mvn --batch-mode clean verify -Dnvd.api.key=${{ secrets.NVD_API_KEY }}
        else
          echo "No NVD API key found. Skipping Dependency-Check..."
          mvn --batch-mode clean verify -Dnvd.skip=true
        fi

    - name: Create Incremental Version Tag
      id: tagger
      run: |
       git fetch --tags  # ğŸ‘ˆ fetch remote tags to ensure local is synced
       LAST_TAG=$(git tag --list 'v0.*' | sort -V | tail -n 1)
       echo "Last tag found: $LAST_TAG"
       if [[ -z "$LAST_TAG" ]]; then
        LAST_TAG="v0.0" #Default if no tag exists
       fi
       # Extract the numeric part, increment
       LAST_MINOR=${LAST_TAG#v0.} # Remove 'v0.' prefix to get minor version
       NEXT_MINOR=$((LAST_MINOR + 1)) # Increment the version number
       NEW_TAG="v0.${NEXT_MINOR}" # Form the new tag
       echo "New tag: $NEW_TAG"
       git tag "$NEW_TAG" # Create new Git tag
       git push https://x-access-token:${{ secrets.GH_PAT }}@github.com/${{ github.repository }}.git --tags # Push tag to remote
       echo "RELEASE_TAG=$NEW_TAG" >> $GITHUB_ENV # Save tag to environment for later use

    - name: Rename JAR to include version
      run: |
        VERSION_TAG=${{ env.RELEASE_TAG }}
        ORIGINAL_JAR=$(ls target/*.jar | grep -v 'original' | head -n 1) #avoids renaming original-*.jar if spring-boot creates both.
        BASENAME=$(basename "$ORIGINAL_JAR" .jar) #basename strips target/ and .jar, giving you the base name from Maven config.
        NEW_JAR_NAME="target/${BASENAME}-${VERSION_TAG}.jar"
        mv "$ORIGINAL_JAR" "$NEW_JAR_NAME"
        echo "VERSIONED_JAR=$NEW_JAR_NAME" >> $GITHUB_ENV
         	   	   	  	  	
    - name: Upload JAR as GitHub Release Asset
      uses: softprops/action-gh-release@v1
      with:
        tag_name: ${{ env.RELEASE_TAG }}   # â† Use the generated tag
        files: ${{ env.VERSIONED_JAR }}    # Uploads the JAR file from Maven's output to the GitHub "Releases" section

    - name: Install GitHub CLI
      run: sudo apt-get install gh -y # Installs GitHub CLI to interact with GitHub programmatically
  deploy-uat:
    if: github.ref_name == 'uat' || github.ref_name == 'staging' # Only run this job if the branch is uat or staging
    needs: build-uat           # ğŸ‘‰ This ensures 'deploy' only runs AFTER the 'build' job finishes successfully
    runs-on: ubuntu-latest     # ğŸ‘‰ GitHub provides a fresh Ubuntu VM for this job

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        # ğŸ‘‰ Pulls the repository into the runner so flyctl can see Dockerfile + fly.toml

      - name: Set up Fly.io
        uses: superfly/flyctl-actions/setup-flyctl@master
        # ğŸ‘‰ Installs the Fly.io CLI (flyctl) into the runner
        #    Needed to run 'flyctl deploy' command

      - name: Deploy to Fly.io
        run: flyctl deploy --remote-only
        env:
          FLY_API_TOKEN: ${{ secrets.FLY_API_TOKEN }}
  deploy-prod:
    if: github.ref_name == 'main' || github.ref_name == 'master' # Only run this job if the branch is main or master
    needs: build-prod          # ğŸ‘‰ This ensures 'deploy' only runs AFTER the 'build' job finishes successfully
    runs-on: ubuntu-latest     # ğŸ‘‰ GitHub provides a fresh Ubuntu VM for this job

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        # ğŸ‘‰ Pulls the repository into the runner so flyctl can see Dockerfile + fly.toml

      - name: Set up Fly.io
        uses: superfly/flyctl-actions/setup-flyctl@master
        # ğŸ‘‰ Installs the Fly.io CLI (flyctl) into the runner
        #    Needed to run 'flyctl deploy' command

      - name: Deploy to Fly.io
        run: flyctl deploy --remote-only
        env:
          FLY_API_TOKEN: ${{ secrets.FLY_API_TOKEN }}